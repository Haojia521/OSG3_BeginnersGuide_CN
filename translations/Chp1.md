# 1 开启OpenSceneGraph之旅

> 在查看各种渲染效果和使用精心挑选的代码片段之前，让我们先了解一下OpenSceneGraph的历史，了解它的结构和功能，并加入社区来在线学习和讨论OSG。你将有机会创建一个OSG风格的“Hello World”应用程序，通过它你可以获得关于OSG语法和结构的必要信息。
>
> 本书中，**OSG** 为 **OpenSceneGraph** 的简写。为简便起见，本书主要使用简写。

在本章，我们将：

* 简要概述场景图概念和OSG的历史
* 了解最新版OSG的基本结构与特性 *（译者注：此处最新版指OSG3.0）*
* 使用一段简单代码亲身体验OSG
* 建立与OSG社区交互的连接

## 1.1 渲染中间件简明概览

在进入OSG的世界之前，假设你已经体验过OpenGL编程了。无论你是享受其中还是感到万分痛苦，你都要使用成堆的矩阵、设置管线状态、查找新的扩展、调用渲染API或命令，并立即在上下文中将数据绘制出来。

渲染中间件是提高抽象级别、以一定灵活性为代价来降低使用低级OpenGL API复杂性的解决方案。在用户程序中，模块化和面向对象的概念经常被应用于管理图元、材质和不同可视化数据集，这节省了大量的开发时间并允许新的功能可以按模块或插件的形式添加进来。

OSG是一款拥有良好设计的渲染中间件应用程序。它实际上是基于 **场景图 (scene graph)** 原理的 **保留渲染 (retained rendering)** （或称延迟渲染）系统，在缓冲区记录渲染命令和数据并在其他时间执行。这允许系统在渲染之前执行各种优化操作，并可实现一个多线程策略来处理复杂场景。

## 1.2 场景图

**场景图 (scene graph)** 是一个通用的数据结构，为了图形数据的高效管理和渲染它定义了图形场景的空间与逻辑关系。它是典型的层级图，包含一个顶级 **根节点 (root node)**，若干能拥有任意数量 **子节点 (child node)** 的 **组节点 (group nodes)**，和一些没有子节点的 **叶节点 (leaf node)**，组成树结构的最底一层。一个典型的场景图不允许存在环结构（一些节点连接成一个闭合链）或孤立元素（一个节点没有子节点或父节点）；

每个 **组节点 (group node)** 可以拥有任意数量的孩子。将这些 **子节点 (child node)** 组织在一起可以使它们共享父节点的信息，并能将它们视为一个整体。默认情况下，由父节点执行的操作会将其效果传递给所有孩子。

同样地，某些节点会有多个 **父节点 (parent node)**，此时这些节点被认为是“实体 (instanced)”，并且 **场景图 (scene graph)** 可以被定义为 **有向无环图 (directed acylic graph, DAG)**。实例化 (instancing)产生了许多有趣的效果，包括数据共享和多通道渲染。

场景图的概念被广泛应用于许多现代化软件和应用程序中，例如AutoCAD、Maya、CorelDraw、VRML、Open Inventor和我们将要研究的——OpenSceneGraph。

## 1.3 OSG测诞生与发展

OpenSceneGraph项目是由Don Burns在1998年发起的。他曾为SGI工作，是一名滑翔爱好者。他在一个简易的Linux PC上写了一个简化的类SGI的 **场景图 (scene graph)** API，命名为SG，这就是OSG的原型。

1999年，一位滑翔机制造商的设计顾问Robert Osfield开始参与这个年轻的项目。他建议将SG作为一个独立的 **开源** 项目继续开发，并很快将其元素移植到Windows中。

---

本章关键词汇中英对照

| 中文 | 英文 || 中文 | 英文 || 中文 | 英文 |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 场景图 | scene graph || 保留渲染 | retained rendering || 根节点 | root node |